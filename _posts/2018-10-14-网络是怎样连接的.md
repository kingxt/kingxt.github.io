---
layout:     post		
title:      "网络是怎样连接的"		
date:       2018-10-14	
author:     "KingXt"		
tags:
    - 网络
---

# 网络是怎样连接的

淘宝手机客户端浏览商品是怎么获取到服务器数据的？这里会衍生出以下一些问题。

<img src="/img/post/network-question.png" width="600"/>

上图一些列问题反映了很多知识点，接下来会一个一个通俗点描述其工作原理。

### 从下面三个方面可以更加有一个直观认识
> 1. 客户端要做的事情
> 2. 网络传输要做的事情
> 3. 服务器要做的事情


### 1. 客户端要做的事情

不管是手机客户端还是pc，客户端发送内容到服务器都需要经过下面几个过程:
> 1. 生成http请求消息
> 2. 向dns服务器查询服务器的ip地址
> 3. 委托协议栈发送消息，创建套接字Socket，发送数据，断开服务器连接

#### 1.1 生成http请求消息
Http请求消息是应用程序生成的，而且有一些第三方库很方便应用开发者生成请求消息内容，比如android应用程序可以用okhttp，ios应用程序可以用NSURLSession，go提供的net库等。但是http请求消息体都有其标准格式，如下图所示：

<img src="/img/post/network-request.png" width="600"/>

http请求消息生成之后，由于应用本身不具备将消息发送到网络功能，这需要将这个任务交给操作系统来实现，但是交给操作系统之前，比如要将域名解析为对应的IP地址。如果本来就是通过IP直接访问，那么这个步骤就省略了。

#### 1.2 向dns服务器查询服务器的ip地址

这里先介绍下IP地址是什么？ 如下图所示：

<img src="/img/post/network-ip.png" width="600"/>

主机号部分的比特全部为0或者全部为1时代表以下两种特殊的含义。
> 1. 主机号部分全部为0代表整个子网而不是子网中的某台设备。
> 2. 主机号部分全部为1代表向子网上所有设备发送包，即广播.

域名解析过程入下图www.lab.glasscom.com所示，肯定会先访问最近的一台DNS服务器，如果最近的DNS服务器没有存放域名对应信息。由于最近的DNS服务器没有存放www.lab.glasscom.com对应的信息，我们需要从顶往下找。最近的 DNS 服务器中保存了根域DNS服务器的信息，因此它会将来自客户端的查询消息转发给根域DNS服务器，根域服务器中也没有www.lab.glasscom.com这个域名，但根据域名结构可以判断这个域名属于com域，因此根域 DNS 服务器会返回它所管理的com域中的DNS服务器的IP地址。接下来最近的DNS服务器又会向com域的DNS服务器发送查询消息com域中也没有www.lab.glasscom.com这个域名的信息，和刚才一样com域服务器会返回它下面的 glasscom.com域的DNS服务器的IP地址。以此类推，只要重复前面的步骤，就可以顺藤摸瓜找到目标DNS服务器。整个过程如下图所示。

<img src="/img/post/network-dns.png" width="600"/>

对于客户端来说，其实还有一部就是本地dns缓存，本地dns缓存也就是在/etc/hosts文件，这也是为啥我们可以在hosts文件中重定向域名对应的ip地址。

#### 1.3 套接字Socket

在建立Socket时候，往往意识不到中间经历过多少局域网，多少路由器。在网络层，Socket需要指定到底是ipv4还是ipv6。下面以TCP为例说下整个Socket套接字过程。
TCP的服务器需要先监听一个端口，一般是先调用bind函数给socket ip地址和端口号。为什么要端口号了？应用程序当一个网络包来的时候，内核要通过TCP头里面的这个端口来找到应用程序，然后把包丢给应用程序。那么为什么又需要IP地址了，有时候一台机器有多个网卡，也就对应多个IP地址，可以选择监听不同的网卡，这样只有发给发送这个网卡的包才会转发给你。

在内核中会为每个socket维护两个队列，一个是已经建立连接的队列，这个队列的三次握手都已经经过了，处于established状态；还有一个是没有完全建立连接的队列，这个队列三次握手还没有完成，处于syn_rcvd状态。
客户端调用connect函数发起连接后，开始三次握手，内核会给客户端分配一个临时端口，一旦握手成功，服务器accept就返回另外一个socket。也即是监听的socket和真正用来传输数据的socket是两个，一个是监听socket另外一个叫已连接socket。

服务器端最大连接数理论上限 = 客户端ip数 * 客户端端口数 = 2的32次方 * 2的16次方，但是这是理论上限，由于操作系统文件描述符限制，socket都是文件，虽然我们可以修改这个文件描述符数目，但是文件描述符都是占用内存的，所以服务器的最大并发远达不到这个数量级。

为了解决Socket套接字限制，出来了三种IO模型(BIO, NIO, AIO)，可以看看这篇文章简单解释。
[https://www.jianshu.com/p/d23f6d261a04](https://www.jianshu.com/p/d23f6d261a04)

socket连接后，需要经历三次握手，那三次握手具体是怎么操作的了，请看下图动画所示：

<img src="../img/post/network-http-handshake.gif" width="600"/>

这里有一个问题，为什么tcp是三次握手，而不是2次，或者4次5次6次了？
如果是两次握手，那么必然是不需要最后一次，这会导致server端发给客户端的包server不知道有没有收到，也就不能确定这个连接是不是有效的。对于大于3次握手也是可以的，但是这真的没有必要。

TCP发送数据完需要关闭socket通道，就需要经历四次挥手，如下图所示：

<img src="/img/post/network-http-close.gif" width="600"/>

从上图看断开连接过程比建立连接过程复杂多了，为啥了？这就好像编程时候申请内存容易但是释放内存难。

这里涉及到的概念比较多，可以参考 [https://www.jianshu.com/p/44655bff60a4](https://www.jianshu.com/p/44655bff60a4)