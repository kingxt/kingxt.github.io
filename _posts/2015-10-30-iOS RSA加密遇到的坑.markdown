---
layout:     post
title:      "èŠèŠã€Œé˜¿é‡Œæ—…è¡Œ Â· å»å•Šã€â€”â€” è¡Œä¸šä¸æˆ˜ç•¥ "
subtitle:   "èŠèŠåœ¨çº¿æ—…è¡Œè¡Œä¸šä¸è€ä¸œå®¶çš„äº§å“æ€è·¯"
date:       2015-06-15
author:     "Hux"
header-img: "img/post-bg-alitrip.jpg"
tags:
    - äº§å“è®¾è®¡
---

# IOS RSAåŠ å¯†é‡åˆ°çš„å‘

------

æœ€è¿‘åœ¨é¡¹ç›®æ¶‰åŠåˆ°ä¸€ç‚¹RSAç®—æ³•é—®é¢˜ï¼ŒRSAæ˜¯éå¯¹ç§°ç§˜é’¥åŠ å¯†ï¼ŒIOSåœ¨Securityä¸­æ”¯æŒå¤§å¤šæ•°åŠ å¯†ç®—æ³•,AES, DES, RSAç­‰ã€‚

æˆ‘åœ¨ç”¨Security.frameworkæ—¶å€™é‡åˆ°ä¸€ä¸ªé—®é¢˜ï¼Œç”¨pemç”ŸæˆPublic Keyæ—¶å€™å‡ºé”™

```objc
 + (SecKeyRef)addPublicKey:(NSString *)key {
	NSRange spos = [key rangeOfString:@"-----BEGIN PUBLIC KEY-----"];
	NSRange epos = [key rangeOfString:@"-----END PUBLIC KEY-----"];
	if(spos.location != NSNotFound && epos.location != NSNotFound){
		NSUInteger s = spos.location + spos.length;
		NSUInteger e = epos.location;
		NSRange range = NSMakeRange(s, e-s);
		key = [key substringWithRange:range];
	}
	//æ³¨æ„ï¼Œä¸­é—´éƒ¨åˆ†æ‰æ˜¯base64åŠ å¯†çš„public keyï¼Œè€Œä¸”éœ€è¦å¹²æ‰æ¢è¡Œç©ºæ ¼
	key = [key stringByReplacingOccurrencesOfString:@"\r" withString:@""];
	key = [key stringByReplacingOccurrencesOfString:@"\n" withString:@""];
	key = [key stringByReplacingOccurrencesOfString:@"\t" withString:@""];
	key = [key stringByReplacingOccurrencesOfString:@" "  withString:@""];
	//base64 è§£å¯†key
	NSData *data = base64_decode(key);
	data = [RSA stripPublicKeyHeader:data];
	if(!data){
		return nil;
	}
	//a tag to read/write keychain storage
	NSString *tag = @"SL_PubKey";
	NSData *d_tag = [NSData dataWithBytes:[tag UTF8String] length:[tag length]];
	
	// å…ˆè¦åˆ æ‰keychainä¸­ä»¥å‰å­˜çš„
	NSMutableDictionary *publicKey = [[NSMutableDictionary alloc] init];
	[publicKey setObject:(__bridge id) kSecClassKey forKey:(__bridge id)kSecClass];
	[publicKey setObject:(__bridge id) kSecAttrKeyTypeRSA forKey:(__bridge id)kSecAttrKeyType];
	[publicKey setObject:d_tag forKey:(__bridge id)kSecAttrApplicationTag];
	SecItemDelete((__bridge CFDictionaryRef)publicKey);
	
	// å°†public keyåŠ å…¥keychainä¸­
	[publicKey setObject:data forKey:(__bridge id)kSecValueData];
	[publicKey setObject:(__bridge id) kSecAttrKeyClassPublic forKey:(__bridge id)
	 kSecAttrKeyClass];
	[publicKey setObject:[NSNumber numberWithBool:YES] forKey:(__bridge id)
	 kSecReturnPersistentRef];
	
	CFTypeRef persistKey = nil;
	OSStatus status = SecItemAdd((__bridge CFDictionaryRef)publicKey, &persistKey);
	if (persistKey != nil){
		CFRelease(persistKey);
	}
	if ((status != noErr) && (status != errSecDuplicateItem)) {
		return nil;
	}

	[publicKey removeObjectForKey:(__bridge id)kSecValueData];
	[publicKey removeObjectForKey:(__bridge id)kSecReturnPersistentRef];
	[publicKey setObject:[NSNumber numberWithBool:YES] forKey:(__bridge id)kSecReturnRef];
	[publicKey setObject:(__bridge id) kSecAttrKeyTypeRSA forKey:(__bridge id)kSecAttrKeyType];
	
	// å–SecKeyRef
	SecKeyRef keyRef = nil;
	status = SecItemCopyMatching((__bridge CFDictionaryRef)publicKey, (CFTypeRef *)&keyRef);
	if(status != noErr){
		return nil;
	}
	return keyRef;
}
```
ä¸Šé¢è¿™æ®µä»£ç æ˜¯æ ¹æ®pemæ ¼å¼æ–‡ä»¶å†…å®¹å­—ç¬¦ä¸²ï¼ˆå› ä¸ºæ˜¯base64è¿‡çš„ï¼‰ç”Ÿæˆpublic keyï¼Œæˆ‘ç”¨iPhone6ï¼ŒiOS9.1è¿æ¥Xcode Debugæµ‹è¯•æ—¶å€™å‘ç°ï¼ŒæŸäº›æƒ…å†µè°ƒç”¨SecItemAddå¾€keychainä¸­æ·»åŠ ç§˜é’¥æ—¶å€™status code è¿”å›-34018ï¼Œæˆ‘googleäº†ä¸€ç•ªï¼Œè¿™æ˜¯IOSçš„bugï¼Œå…·ä½“è¯·å‚è€ƒ

> https://forums.developer.apple.com/thread/4743#14441

è¿™ä¸ªbugåªä¼šåœ¨deviceè¿æ¥xcodeè°ƒè¯•æ—¶å€™å‡ºç°ï¼Œæ–­å¼€è°ƒè¯•ç”¨deviceç›´æ¥è·‘çš„æ—¶å€™ä¸ä¼šå‡ºç°æ·»åŠ å¤±è´¥æƒ…å†µã€‚è¿˜æ²¡æœ‰æ‰¾åˆ°è§£å†³æ–¹æ¡ˆğŸ˜­ã€‚

ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘æ‰“ç®—æ”¾å¼ƒä½¿ç”¨iOSè‡ªå¸¦çš„RSAï¼Œæ”¹ç”¨opensslçš„RSAå®ç°ã€‚ä»£ç å¦‚ä¸‹ï¼š
```c
NSString *rsa_public_encrypt(NSData *data, void *public_key_val) {
    RSA *rsa_publicKey = NULL;
    int rsa_public_len;
    BIO *bio = NULL;
    bio = BIO_new_mem_buf(public_key_val, -1);
    if (bio == NULL){
        printf("Pub Key Read Failure\n");
    }
    rsa_publicKey = PEM_read_bio_RSA_PUBKEY(bio, NULL, NULL, NULL);
    if (rsa_publicKey == NULL) {
        printf("RSA Generate failure\n");
    };
    
    rsa_public_len = RSA_size(rsa_publicKey);
    printf("RSA public length: %d\n", rsa_public_len);
    
    // 11 bytes is overhead required for encryption
    int chunk_length = rsa_public_len - 11;
    // plain text length
    unsigned long dataLength = data.length;
    // calculate the number of chunks
    int num_of_chunks = (int)(dataLength / chunk_length) + 1;
    
    int total_cipher_length = 0;
    
    // the output size is (total number of chunks) x (the key length)
    int encrypted_size = (num_of_chunks * rsa_public_len);
    unsigned char *cipher_data = malloc(encrypted_size + 1);
    
    const void *plainBytes = data.bytes;
    char *err = NULL;
    for (int i = 0; i < dataLength; i += chunk_length) {
        
        // get the remaining character count from the plain text
        int remaining_char_count = (int)dataLength - i;
        
        // this len is the number of characters to encrypt, thus take the minimum between the chunk count & the remaining characters
        // this must less than rsa_public_len - 11
        int len = RSMIN(remaining_char_count, chunk_length);
        unsigned char *plain_chunk = malloc(len + 1);
        // take out chunk of plain text
        memcpy(&plain_chunk[0], &plainBytes[i], len);
        unsigned char *result_chunk = malloc(rsa_public_len + 1);
        int result_length = RSA_public_encrypt(len, plain_chunk, result_chunk, rsa_publicKey, RSA_PKCS1_PADDING);
        free(plain_chunk);
        if (result_length == -1) {
            ERR_load_CRYPTO_strings();
            fprintf(stderr, "Error %s\n", ERR_error_string(ERR_get_error(), err));
            fprintf(stderr, "Error %s\n", err);
        }
        memcpy(&cipher_data[total_cipher_length], &result_chunk[0], result_length);
        
        total_cipher_length += result_length;
        
        free(result_chunk);
    }
    RSA_free(rsa_publicKey);
    size_t total_len = 0;
    unsigned char *encrypted = rsa_base64_encode(cipher_data, encrypted_size, &total_len);
    free(cipher_data);
    
    return [[NSString alloc] initWithBytes:encrypted length:total_len encoding:NSUTF8StringEncoding];
}

NSData *rsa_public_decrypt(NSData *data, void *public_key_val) {
    RSA *rsa_publicKey = NULL;
    int rsa_public_len;
    BIO *bio = NULL;
    
    bio = BIO_new_mem_buf(public_key_val, -1);
    if (bio == NULL){
        printf("Public Key Read Failure\n");
    }
    rsa_publicKey = PEM_read_bio_RSA_PUBKEY(bio, NULL, NULL, NULL);
    if (rsa_publicKey == NULL) {
        printf("RSA Generate failure\n");
    }
    
    rsa_public_len = RSA_size(rsa_publicKey);
    printf("RSA public length: %d\n", rsa_public_len);
    
    size_t crypt_len = data.length;
    
    const char *crypt = data.bytes;
    
    NSMutableData *result = [NSMutableData data];
    char *err = NULL;
    for (int i = 0; i < crypt_len; i += rsa_public_len) {
        unsigned char *crypt_chunk = malloc(rsa_public_len);
        memcpy(&crypt_chunk[0], &crypt[i], rsa_public_len);
        unsigned char *result_chunk = malloc(crypt_len + 1);
        int result_length = RSA_public_decrypt(rsa_public_len, crypt_chunk, result_chunk, rsa_publicKey, RSA_PKCS1_PADDING);
        free(crypt_chunk);
        [result appendBytes:result_chunk length:result_length];
        free(result_chunk);
        if (result_length == -1) {
            ERR_load_CRYPTO_strings();
            fprintf(stderr, "Error %s\n", ERR_error_string(ERR_get_error(), err));
            fprintf(stderr, "Error %s\n", err);
        }
    }
    RSA_free(rsa_publicKey);
    return result;
}
```
è¿™é‡Œæœ‰å‡ ä¸ªé—®é¢˜è¦æ³¨æ„ï¼š
 

> 1ã€å…¬é’¥å­—ç¬¦ä¸²æ¯ä¸€è¡Œåé¢è¦åŠ ä¸€ä¸ª\n
> 2ã€åŠ å¯†åçš„æ•°æ®é•¿åº¦
> 3ã€è§£å¯†åçš„æ•°æ®é•¿åº¦

 

